{
  "name": "bilby",
  "description": "Serious functional programming library for JavaScript",
  "author": {
    "name": "Brian McKenna",
    "email": "brian@brianmckenna.org",
    "url": "http://brianmckenna.org/"
  },
  "homepage": "http://bilby.brianmckenna.org/",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/pufuwozu/bilby.js.git"
  },
  "scripts": {
    "prepublish": "./node_modules/grunt/bin/grunt",
    "test": "./node_modules/grunt/bin/grunt lint rigger test"
  },
  "devDependencies": {
    "grunt": "0.3.15",
    "rigger": "0.3.19",
    "emu": "0.0.2"
  },
  "main": "bilby.js",
  "version": "0.0.2",
  "readme": "% bilby.js\n\n![](http://brianmckenna.org/files/bilby.png)\n\n[![Build Status](https://secure.travis-ci.org/pufuwozu/bilby.js.png)](http://travis-ci.org/pufuwozu/bilby.js)\n\n# Description\n\nbilby.js is a serious functional programming library. Serious,\nmeaning it applies category theory to enable highly abstract\nand generalised code. Functional, meaning that it enables\nreferentially transparent programs.\n\nSome features include:\n\n* Immutable multimethods for ad-hoc polymorphism\n* Functional data structures\n* Operator overloading for functional syntax\n* Automated specification testing (ScalaCheck, QuickCheck)\n\n# Usage\n\nnode.js:\n\n    var bilby = require('bilby');\n\nBrowser:\n\n    <script src=\"bilby-min.js\"></script>\n\n# Development\n\nDownload the code with git:\n\n    git clone https://github.com/pufuwozu/bilby.js.git\n\nInstall the development dependencies with npm:\n\n    npm install\n\nRun the tests with grunt:\n\n    npm test\n\nBuild the concatenated scripts with grunt:\n\n    $(npm bin)/grunt\n\nGenerate the documentation with emu:\n\n    $(npm bin)/emu < bilby.js\n\n# Environment\n    \nEnvironments are very important in bilby. The library itself is\nimplemented as a single environment.\n    \nAn environment holds methods and properties.\n    \nMethods are implemented as multimethods, which allow a form of\n*ad-hoc polymorphism*. Duck typing is another example of ad-hoc\npolymorphism but only allows a single implementation at a time, via\nprototype mutation.\n    \nA method instance is a product of a name, a predicate and an\nimplementation:\n    \n    var env = bilby.environment()\n        .method(\n            // Name\n            'negate',\n            // Predicate\n            function(n) {\n                return typeof n == 'number';\n            },\n            // Implementation\n            function(n) {\n                return -n;\n            }\n        );\n    \n    env.negate(100) == -100;\n    \nWe can now override the environment with some more implementations:\n    \n    var env2 = env\n        .method(\n            'negate',\n            function(b) {\n                return typeof b == 'boolean';\n            },\n            function(b) {\n                return !b;\n            }\n        );\n    \n    env2.negate(100) == -100;\n    env2.negate(true) == false;\n    \nThe environments are immutable; references to `env` won't see an\nimplementation for boolean. The `env2` environment could have\noverwritten the implementation for number and code relying on `env`\nwould still work.\n    \nProperties can be accessed without dispatching on arguments. They\ncan almost be thought of as methods with predicates that always\nreturn true:\n    \n    var env = bilby.environment()\n        .property('name', 'Brian');\n    \n    env.name == 'Brian';\n    \nThis means that bilby's methods can be extended:\n    \n    function MyData(data) {\n        this.data = data;\n    }\n    \n    var _ = bilby.method(\n        'equal',\n        bilby.isInstanceOf(MyData),\n        function(a, b) {\n            return this.equal(a.data, b.data);\n        }\n    );\n    \n    _.equal(\n        new MyData(1),\n        new MyData(1)\n    ) == true;\n    \n    _.equal(\n        new MyData(1),\n        new MyData(2)\n    ) == false;\n\n## environment(methods = {}, properties = {})\n    \n* method(name, predicate, f) - adds an multimethod implementation\n* property(name, value) - sets a property to value\n* envConcat(extraMethods, extraProperties) - adds methods + properties\n* envAppend(e) - combines two environemts, biased to `e`\n\n# Helpers\n    \nThe helpers module is a collection of functions used often inside\nof bilby.js or are generally useful for programs.\n\n## functionName(f)\n    \nReturns the name of function `f`.\n\n## functionLength(f)\n    \nReturns the arity of function `f`.\n\n## bind(f)(o)\n    \nMakes `this` inside of `f` equal to `o`:\n    \n    bilby.bind(function() { return this; })(a)() == a\n    \nAlso partially applies arguments:\n    \n    bilby.bind(bilby.add)(null, 10)(32) == 42\n\n## curry(f)\n    \nTakes a normal function `f` and allows partial application of its\nnamed arguments:\n    \n    var add = bilby.curry(function(a, b) {\n            return a + b;\n        }),\n        add15 = add(15);\n    \n    add15(27) == 42;\n    \nRetains ability of complete application by calling the function\nwhen enough arguments are filled:\n    \n    add(15, 27) == 42;\n\n## flip(f)\n    \nFlips the order of arguments to `f`:\n    \n    var append = bilby.curry(function(a, b) {\n            return a + b;\n        }),\n        prepend = flip(concat);\n\n## identity(o)\n    \nIdentity function. Returns `o`:\n    \n    forall a. identity(a) == a\n\n## constant(c)\n    \nConstant function. Creates a function that always returns `c`, no\nmatter the argument:\n    \n    forall a b. constant(a)(b) == a\n\n## compose(f, g)\n    \nCreates a new function that applies `f` to the result of `g` of the\ninput argument:\n    \n    forall f g x. compose(f, g)(x) == f(g(x))\n\n## create(proto)\n    \nPartial polyfill for Object.create - creates a new instance of the\ngiven prototype.\n\n## tagged(name, fields)\n    \nCreates a simple constructor for a tagged object.\n    \n    var Tuple = tagged('Tuple', ['a', 'b']);\n    var x = Tuple(1, 2);\n    var y = new Tuple(3, 4);\n    x instanceof Tuple && y instanceof Tuple;\n\n## taggedSum(constructors)\n    \nCreates a disjoint union of constructors, with a catamorphism.\n    \n    var List = taggedSum({\n        Cons: ['car', 'cdr'],\n        Nil: []\n    });\n    function listLength(l) {\n        return l.cata({\n            Cons: function(car, cdr) {\n                return 1 + listLength(cdr);\n            },\n            Nil: function() {\n                return 0;\n            }\n        });\n    }\n    listLength(List.Cons(1, new List.Cons(2, List.Nil()))) == 2;\n\n## error(s)\n    \nTurns the `throw new Error(s)` statement into an expression.\n\n## zip(a, b)\n    \nTakes two lists and pairs their values together into a \"tuple\" (2\nlength list):\n    \n    zip([1, 2, 3], [4, 5, 6]) == [[1, 4], [2, 5], [3, 6]]\n\n## singleton(k, v)\n    \nCreates a new single object using `k` as the key and `v` as the\nvalue. Useful for creating arbitrary keyed objects without\nmutation:\n    \n    singleton(['Hello', 'world'].join(' '), 42) == {'Hello world': 42}\n\n## extend(a, b)\n    \nRight-biased key-value append of objects `a` and `b`:\n    \n    bilby.extend({a: 1, b: 2}, {b: true, c: false}) == {a: 1, b: true, c: false}\n\n## isTypeOf(s)(o)\n    \nReturns `true` iff `o` has `typeof s`.\n\n## isFunction(a)\n    \nReturns `true` iff `a` is a `Function`.\n\n## isBoolean(a)\n    \nReturns `true` iff `a` is a `Boolean`.\n\n## isNumber(a)\n    \nReturns `true` iff `a` is a `Number`.\n\n## isString(a)\n    \nReturns `true` iff `a` is a `String`.\n\n## isArray(a)\n    \nReturns `true` iff `a` is an `Array`.\n\n## isInstanceOf(c)(o)\n    \nReturns `true` iff `o` is an instance of `c`.\n\n## AnyVal\n    \nSentinal value for when any type of primitive value is needed.\n\n## Char\n    \nSentinal value for when a single character string is needed.\n\n## arrayOf(type)\n    \nSentinal value for when an array of a particular type is needed:\n    \n    arrayOf(Number)\n\n## isArrayOf(a)\n    \nReturns `true` iff `a` is an instance of `arrayOf`.\n\n## objectLike(props)\n    \nSentinal value for when an object with specified properties is\nneeded:\n    \n    objectLike({\n        age: Number,\n        name: String\n    })\n\n## isObjectLike(a)\n    \nReturns `true` iff `a` is an instance of `objectLike`.\n\n## or(a)(b)\n    \nCurried function for `||`.\n\n## and(a)(b)\n    \nCurried function for `&&`.\n\n## add(a)(b)\n    \nCurried function for `+`.\n\n## strictEquals(a)(b)\n    \nCurried function for `===`.\n\n## liftA2(f, a, b)\n    \nLifts a curried, binary function `f` into the applicative passes\n`a` and `b` as parameters.\n\n## sequence(m, a)\n    \nSequences an array, `a`, of values belonging to the `m` monad:\n    \n     bilby.sequence(Array, [\n         [1, 2],\n         [3],\n         [4, 5]\n     ]) == [\n         [1, 3, 4],\n         [1, 3, 5],\n         [2, 3, 4],\n         [2, 3, 5]\n     ]\n\n# Trampoline\n    \nReifies continutations onto the heap, rather than the stack. Allows\nefficient tail calls.\n    \nExample usage:\n    \n    function loop(n) {\n        function inner(i) {\n            if(i == n) return bilby.done(n);\n            return bilby.cont(function() {\n                return inner(i + 1);\n            });\n        }\n    \n        return bilby.trampoline(inner(0));\n    }\n    \nWhere `loop` is the identity function for positive numbers. Without\ntrampolining, this function would take `n` stack frames.\n\n## done(result)\n    \nResult constructor for a continuation.\n\n## cont(thunk)\n    \nContinuation constructor. `thunk` is a nullary closure, resulting\nin a `done` or a `cont`.\n\n## trampoline(bounce)\n    \nThe beginning of the continuation to call. Will repeatedly evaluate\n`cont` thunks until it gets to a `done` value.\n\n# Do (operator overloading)\n    \nAdds operator overloading for functional syntax:\n    \n  * `>=` - monad flatMap/bind:\n    \n        bilby.Do()(\n            bilby.some(1) >= function(x) {\n                return x < 0 ? bilby.none : bilby.some(x + 2);\n            }\n        ).getOrElse(0) == 3;\n    \n  * `>>` - kleisli:\n    \n        bilby.Do()(\n            function(x) {\n                return x < 0 ? bilby.none : bilby.some(x + 1);\n            } >> function(x) {\n                return x % 2 != 0 ? bilby.none : bilby.some(x + 1);\n            }\n        )(1).getOrElse(0) == 3;\n    \n  * `<` - functor map:\n    \n        bilby.Do()(\n            bilby.some(1) < add(2)\n        ).getOrElse(0) == 3;\n    \n  * `*` - applicative ap(ply):\n    \n        bilby.Do()(\n            bilby.some(add) * bilby.some(1) * bilby.some(2)\n        ).getOrElse(0) == 3;\n    \n  * `+` - semigroup append:\n    \n        bilby.Do()(\n            bilby.some(1) + bilby.some(2)\n        ).getOrElse(0) == 3;\n\n## Do()(a)\n    \nCreates a new syntax scope. The `a` expression is allowed multiple\nusages of a single operator per `Do` call:\n    \n* `>=` - flatMap\n* `>>` - kleisli\n* `<` - map\n* `*` - ap\n* `+` - append\n    \nThe associated name will be called on the bilby environment with\nthe operands. For example:\n    \n    bilby.Do()(bilby.some(1) + bilby.some(2))\n    \nDesugars into:\n    \n    bilby.append(bilby.some(1), bilby.some(2))\n\n## Do.setValueOf(proto)\n    \nUsed to mutate the `valueOf` property on `proto`. Necessary to do\nthe `Do` block's operator overloading. Uses the object's existing\n`valueOf` if not in a `Do` block.\n    \n*Warning:* this mutates `proto`. May not be safe, even though it\ntries to default back to the normal behaviour when not in a `Do`\nblock.\n\n# Data structures\n    \nChurch-encoded versions of common functional data\nstructures. Disjunction is enoded by multiple constructors with\ndifferent implementations of common functions.\n\n## Option\n    \n    Option a = Some a + None\n    \nThe option type encodes the presence and absence of a value. The\n`some` constructor represents a value and `none` represents the\nabsence.\n    \n* fold(a, b) - applies `a` to value if `some` or defaults to `b`\n* getOrElse(a) - default value for `none`\n* isSome - `true` iff `this` is `some`\n* isNone - `true` iff `this` is `none`\n* toLeft(r) - `left(x)` if `some(x)`, `right(r)` if none\n* toRight(l) - `right(x)` if `some(x)`, `left(l)` if none\n* flatMap(f) - monadic flatMap/bind\n* map(f) - functor map\n* ap(s) - applicative ap(ply)\n* append(s, plus) - semigroup append\n\n### some(x)\n    \nConstructor to represent the existance of a value, `x`.\n\n### none\n    \nRepresents the absence of a value.\n\n## isOption(a)\n    \nReturns `true` iff `a` is a `some` or `none`.\n\n## Either\n    \n    Either a b = Left a + Right b\n    \nRepresents a tagged disjunction between two sets of values; `a` or\n`b`. Methods are right-biased.\n    \n* fold(a, b) - `a` applied to value if `left`, `b` if `right`\n* swap() - turns `left` into `right` and vice-versa\n* isLeft - `true` iff `this` is `left`\n* isRight - `true` iff `this` is `right`\n* toOption() - `none` if `left`, `some` value of `right`\n* toArray() - `[]` if `left`, singleton value if `right`\n* flatMap(f) - monadic flatMap/bind\n* map(f) - functor map\n* ap(s) - applicative ap(ply)\n* append(s, plus) - semigroup append\n\n### left(x)\n    \nConstructor to represent the left case.\n\n### right(x)\n    \nConstructor to represent the (biased) right case.\n\n## isEither(a)\n    \nReturns `true` iff `a` is a `left` or a `right`.\n\n# Validation\n    \n    Validation e v = Failure e + Success v\n    \nThe Validation data type represents a \"success\" value or a\nsemigroup of \"failure\" values. Validation has an applicative\nfunctor which collects failures' errors or creates a new success\nvalue.\n    \nHere's an example function which validates a String:\n    \n    function nonEmpty(field, string) {\n        return string\n            ? λ.success(string)\n            : λ.failure([field + \" must be non-empty\"]);\n    }\n    \nWe might want to give back a full-name from a first-name and\nlast-name if both given were non-empty:\n    \n    function getWholeName(firstName) {\n        return function(lastName) {\n            return firstName + \" \" + lastName;\n        }\n    }\n    λ.ap(\n        λ.map(nonEmpty(\"First-name\", firstName), getWholeName),\n        nonEmpty(\"Last-name\", lastName)\n    );\n    \nWhen given a non-empty `firstName` (\"Brian\") and `lastName`\n(\"McKenna\"):\n    \n    λ.success(\"Brian McKenna\");\n    \nIf given only an invalid `firstname`:\n    \n    λ.failure(['First-name must be non-empty']);\n    \nIf both values are invalid:\n    \n    λ.failure([\n        'First-name must be non-empty',\n        'Last-name must be non-empty'\n    ]);\n    \n* map(f) - functor map\n* ap(b, append) - applicative ap(ply)\n    \n## success(value)\n    \nRepresents a successful `value`.\n    \n## failure(errors)\n    \nRepresents a failure.\n    \n`errors` **must** be a semigroup (i.e. have an `append`\nimplementation in the environment).\n\n## isValidation(a)\n    \nReturns `true` iff `a` is a `success` or a `failure`.\n\n# Lenses\n    \nLenses allow immutable updating of nested data structures.\n\n## store(setter, getter)\n    \nA `store` is a combined getter and setter that can be composed with\nother stores.\n\n## isStore(a)\n    \nReturns `true` iff `a` is a `store`.\n\n## lens(f)\n    \nA total `lens` takes a function, `f`, which itself takes a value\nand returns a `store`.\n    \n* run(x) - gets the lens' `store` from `x`\n* compose(l) - lens composition\n\n## isLens(a)\n    \nReturns `true` iff `a` is a `lens`.\n\n## objectLens(k)\n    \nCreates a total `lens` over an object for the `k` key.\n\n# Input/output\n    \nPurely functional IO wrapper.\n\n## io(f)\n    \nPure wrapper around a side-effecting `f` function.\n    \n* perform() - action to be called a single time per program\n* flatMap(f) - monadic flatMap/bind\n\n## isIO(a)\n    \nReturns `true` iff `a` is an `io`.\n\n# QuickCheck\n    \nQuickCheck is a form of *automated specification testing*. Instead\nof manually writing tests cases like so:\n    \n    assert(0 + 1 == 1);\n    assert(1 + 1 == 2);\n    assert(3 + 3 == 6);\n    \nWe can just write the assertion algebraicly and tell QuickCheck to\nautomaticaly generate lots of inputs:\n    \n    bilby.forAll(\n        function(n) {\n            return n + n == 2 * n;\n        },\n        [Number]\n    ).fold(\n        function(fail) {\n            return \"Failed after \" + fail.tries + \" tries: \" + fail.inputs.toString();\n        },\n        \"All tests passed!\",\n    )\n\n### failureReporter\n    \n* inputs - the arguments to the property that failed\n* tries - number of times inputs were tested before failure\n\n## forAll(property, args)\n    \nGenerates values for each type in `args` using `bilby.arb` and\nthen passes them to `property`, a function returning a\n`Boolean`. Tries `goal` number of times or until failure.\n    \nReturns an `Option` of a `failureReporter`:\n    \n    var reporter = bilby.forAll(\n        function(s) {\n            return isPalindrome(s + s.split('').reverse().join(''));\n        },\n        [String]\n    );\n\n## goal\n    \nThe number of successful inputs necessary to declare the whole\nproperty a success:\n    \n    var _ = bilby.property('goal', 1000);\n    \nDefault is `100`.",
  "readmeFilename": "README.md",
  "_id": "bilby@0.0.2",
  "dist": {
    "shasum": "7b5da3d0570eeb688d3c595dce610b18b6f3aef7",
    "tarball": "http://registry.npmjs.org/bilby/-/bilby-0.0.2.tgz"
  },
  "_from": "bilby@>=0.0.0 <0.1.0",
  "_npmVersion": "1.2.15",
  "_npmUser": {
    "name": "puffnfresh",
    "email": "brian@brianmckenna.org"
  },
  "maintainers": [
    {
      "name": "puffnfresh",
      "email": "puffnfresh@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "7b5da3d0570eeb688d3c595dce610b18b6f3aef7",
  "_resolved": "https://registry.npmjs.org/bilby/-/bilby-0.0.2.tgz"
}
